\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}

\newcommand{\dispRity}{\texttt{dispRity} }
\newcommand{\R}{\texttt{R} }

\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


\title{dispRity metrics}


\author{Thomas Guillerme}

\maketitle

This vignette details how the disparity metrics are implemented in the \dispRity package (v.\Sexpr{packageVersion("dispRity")}).

\section{Disparity metrics}
There are many ways for measuring disparity.
In brief, disparity is a summary metric that will represent an aspect of an ordinated space (e.g. MDS, PCA, PCO, PCoA).
For example, one can look at ellipsoid hyper-volume of the ordinated space \cite{DonohueDim}, the sum and the product of the ranges and variances of the ordinated space dimensions \cite{Wills1994} or the median position of the elements in the ordinated space relative to its centroid \cite{GuillermeSTD}.
Of course, there is many more examples of metrics one can use for describing some aspect of the ordinated space, with some performing better than other ones at particular descriptive tasks or some being more generalist.

Because of this great diversity of metric, the package \dispRity has not a unique way to measure disparity but rather proposes to facilitate users to define their own disparity metric that will best suit to their particular analysis.
In fact, the core function of the package, \dispRity, allows the user to define any metric in the \texttt{metric} argument.
However, because of the infrastructure of the package (especially the on of the \dispRity objects -- see the \href{https://github.com/TGuillerme/dispRity}{other dispRity demos}), the \texttt{metric} argument has to follow certain slightly restrictive rules described in detail below.
\begin{enumerate}
    \item \texttt{metric} must be between one or three \texttt{function} objects
    \item \texttt{metric} must intake a \texttt{matrix} or \texttt{vector} object
    \item \texttt{metric} individual functions must be classified in one of the three levels
    \item \texttt{metric} one of the functions must be a level 1 function
\end{enumerate}

\section{The function levels}
The metric functions levels determine the dimensional level of decomposition of the input \texttt{matrix}.
In other words, each level designate the dimensions of the output: either three (a \texttt{matrix}); two (a \texttt{vector}); or one (a single \texttt{numeric} value) dimensions (see \ref{fun_type}).

\begin{figure}[!htbp]
\centering
    \includegraphics[keepaspectratio=true]{dispRity_fun.pdf}
    \caption{Illustration of the different levels of output of a function with an input \texttt{matrix}}
    \label{fun_type}
\end{figure}

\newpage

\subsection{A level 1 function}
A level 1 function for example, will decompose the \texttt{matrix} (or a \texttt{vector} output from a level 2 function, see below) into a single value:

<<level 1 example>>=
## First, let's create a dummy matrix
dummy_matrix <- matrix(rnorm(12), 4, 3)
## Any summary metric such as mean or median are good examples of level 1
## functions as they reduce the matrix to a single dimensions (value):
mean(dummy_matrix)
median(dummy_matrix)
@ 

\subsection{A level 2 function}
A level 2 function for example, will decompose the \texttt{matrix} into a \texttt{vector}.
Several level 2 functions are implemented in \dispRity (see \texttt{?dispRity.metric}) such as the \texttt{variances} function that calculates the variance of each column of the ordinated matrix (or axis/dimensions):

<<level 2 example>>=
## We can define a different function that outputs the products of the rows:
rows <- function(matrix) apply(matrix, 1, prod)
## Rows is a level 2 function as well (outputs a vector of 4 values):
rows(dummy_matrix)
@ 

\subsection{A level 3 function}
Finally a level 3 function will transform the \texttt{matrix} into another \texttt{matrix}.
Note that the dimension of the output \texttt{matrix} don't need to match the the input \texttt{matrix}:

<<level 3 example>>=
## The var functions computes the variance/covariance matrix which will be a
## three by three matrix
var(dummy_matrix)
@ 

\section{\texttt{make.metric}}
Of course, functions can be more complex and involve multiple operations such as the \texttt{centroids} function (see \texttt{?dispRity.metric}) that calculates the euclidean distance between each elements and the ordinated space centroid.
The \texttt{make.metric} function implemented in \dispRity is designed to help testing and finding the level of the functions.
Concretely, This function tests:
\begin{enumerate}
  \item if your function can deal with a matrix as an \texttt{input}.
  \item which level is your function (level 1, 2 or 3, see \texttt{?dispRity.metric}).
  \item whether the function can properly be implemented in the \texttt{dispRity} function.
\end{enumerate}
For example, let's see if the functions described above are the right levels:

<<make.metric example>>=
## First we need to load the package
library(dispRity)
## Which level is the mean function? And is able to be used in the dispRity function?
make.metric(mean)
## Which level is the rows function? And is able to be used in the dispRity function?
make.metric(rows)
## Note that the function also tells us that we will need a level 1 function as well.
## We'll cover this below.
## Which level is the var function? And is able to be used in the dispRity function?
make.metric(var)
@ 

\section{metric argument in \dispRity}
Using this metric structure, on can easily use any disparity metric in the \dispRity function as follows:

<<dispRity example>>=
## First we need to load the data
data(BeckLee_mat50)
## Measuring disparity as the standard deviation of all the value of the ordinated
## matrix (level 1 function).
summary(dispRity(BeckLee_mat50, metric = sd))
## Measuring disparity as the standard deviation of the variance of each axis of
## the ordinated matrix (level 1 and level 2 functions).
summary(dispRity(BeckLee_mat50, metric = c(sd, variances)))
## Measuring disparity as the standard deviation of the variance of each axis of
## the variance covariance matrix (level 1, level 2 and level 3 functions).
summary(dispRity(BeckLee_mat50, metric = c(sd, variances, var)), round=10)
## Note that the order of each function in the metric argument does not matter,
## the algorithm always classifies them by levels and computes first level 3,
## then level 2 and finally level 1.
summary(dispRity(BeckLee_mat50, metric = c(variances, sd, var)), round=10)
## Both ways output the same disparity values.
@ 

\bibliographystyle{vancouver}
\bibliography{References}

\end{document}