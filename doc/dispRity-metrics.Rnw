\documentclass{article}

% \VignetteIndexEntry{dispRity-metrics}
% \VignetteEngine{knitr::knitr}

\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{natbib}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}

\newcommand{\dispRity}{\texttt{dispRity} }
\newcommand{\R}{\texttt{R} }

\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


\title{\texttt{dispRity} metrics}


\author{Thomas Guillerme}

\maketitle

This vignette details how the disparity metrics are implemented in the \dispRity package (v.\Sexpr{packageVersion("dispRity")}).

\section{Disparity metrics}
There are many ways for measuring disparity.
In brief, disparity is a summary metric that will represent an aspect of an ordinated space (e.g. MDS, PCA, PCO, PCoA).
For example, one can look at ellipsoid hyper-volume of the ordinated space \citep{DonohueDim}, the sum and the product of the ranges and variances of the ordinated space dimensions \citep{Wills1994} or the median position of the elements in the ordinated space relative to its centroid \citep{GuillermeSTD}.
Of course, there are many more examples of metrics one can use for describing some aspect of the ordinated space, with some performing better than other ones at particular descriptive tasks or some being more generalist.

Because of this great diversity of metric, the package \dispRity has not a unique way to measure disparity but rather proposes to facilitate users to define their own disparity metric that will best suit to their particular analysis.
In fact, the core function of the package, \dispRity, allows the user to define any metric in the \texttt{metric} argument.
However, because of the infrastructure of the package (especially the one of the \dispRity objects -- see the \href{https://github.com/TGuillerme/dispRity/blob/master/doc/dispRity-manual.pdf}{\dispRity manual}), the \texttt{metric} argument has to follow certain rules:
\begin{enumerate}
    \item it must be composed of one to three \texttt{function} objects;
    \item these functions can only have as input a \texttt{matrix} or a \texttt{vector};
    \item each of these functions must be of one of the three levels described below;
    \item at least one of the functions must be a level 1 function (see below).
\end{enumerate}

\section{The function levels}
The metric functions levels determine the dimensional level of decomposition of the input \texttt{matrix}.
In other words, each level designate the dimensions of the output: either three (a \texttt{matrix}); two (a \texttt{vector}); or one (a single \texttt{numeric} value) dimensions (see \ref{fun_type}).

\begin{figure}[!htbp]
\centering
    \includegraphics[keepaspectratio=true]{dispRity_fun.pdf}
    \caption{Illustration of the different levels of output of a function with an input \texttt{matrix}}
    \label{fun_type}
\end{figure}

\newpage

\subsection{A level 1 function}
A level 1 function for example, will decompose a \texttt{matrix} or a \texttt{vector} into a single value:

<<level 1 example>>=
## First, let's create a dummy matrix
dummy_matrix <- matrix(rnorm(12), 4, 3)

## Any summary metric such as mean or median are good examples of level 1
## functions as they reduce the matrix to a single dimension (i.e. one value):
mean(dummy_matrix)
median(dummy_matrix)
@ 

\subsection{A level 2 function}
A level 2 function will decompose a \texttt{matrix} into a \texttt{vector}.
Several level 2 functions are implemented in \dispRity (see \texttt{?dispRity.metric}) such as the \texttt{variances} function that calculates the variance of each dimension of the ordinated matrix.

<<level 2 example>>=
## We can define a function that outputs the products of each row of the matrix:
prod.rows <- function(matrix) apply(matrix, 1, prod)

## This function is a level 2 function as it reduces the matrix into a two
## dimensional element (a vector of values):
prod.rows(dummy_matrix)
@ 

\subsection{A level 3 function}
Finally a level 3 function will transform the \texttt{matrix} into another \texttt{matrix}.
Note that the dimension of the output \texttt{matrix} don't need to match the the input \texttt{matrix}:

<<level 3 example>>=
## The var functions computes the variance/covariance matrix which will be a
## three by three matrix
var(dummy_matrix)
@ 

\section{\texttt{make.metric}}
Of course, functions can be more complex and involve multiple operations such as the \texttt{centroids} function (see \texttt{?dispRity.metric}) that calculates the euclidean distance between each elements and the ordinated space centroid.
The \texttt{make.metric} function implemented in \dispRity is designed to help testing and finding the level of the functions.
This function tests:
\begin{enumerate}
  \item if your function can deal with a \texttt{matrix} or a \texttt{vector} as an input;
  \item which is your function's level according to it's output (level 1, 2 or 3, see above);
  \item whether the function can properly be implemented in the \texttt{dispRity} function (the function is fed into a \texttt{lapply} loop.
\end{enumerate}
For example, let's see if the functions described above are the right levels:

<<make.metric example>>=
## First we need to load the package
library(dispRity)

## Which level is the mean function? And is able to be used in the dispRity?
make.metric(mean)

## Same questions from the prod.rows function:
make.metric(prod.rows)
## Note that the function also tells us that we will need a level 1 function as well.
## We'll cover this below.

## Same questions for the var function:
make.metric(var)
@ 

\section{metric argument in \dispRity}
Using this metric structure, on can easily use any disparity metric in the \dispRity function as follows:

<<dispRity example>>=
## First we need to load the data
data(BeckLee_mat50)

## Measuring disparity as the standard deviation of all the value of the
## ordinated matrix (level 1 function).
summary(dispRity(BeckLee_mat50, metric = sd))

## Measuring disparity as the standard deviation of the variance of each axis of
## the ordinated matrix (level 1 and level 2 functions).
summary(dispRity(BeckLee_mat50, metric = c(sd, variances)))

## Measuring disparity as the standard deviation of the variance of each axis of
## the variance covariance matrix (level 1, level 2 and level 3 functions).
summary(dispRity(BeckLee_mat50, metric = c(sd, variances, var)), round=10)

@ 

\noindent Note that the order of each function in the metric argument does not matter, the \dispRity function will automatically detect the function levels (using \texttt{make.metric}) and apply them to the data in decreasing order (level 3 $>$ level 2 $>$ level 1).

<<dispRity example2>>=
## Disparity as the standard deviation of the variance of each axis of the
## variance covariance matrix:
disparity1 <- summary(dispRity(BeckLee_mat50, metric = c(sd, variances, var)),
  round=10)

## Same but using a different functions order for the metric argument
disparity2 <- summary(dispRity(BeckLee_mat50, metric = c(variances, sd, var)),
  round=10)

## Both ways output the same disparity values:
disparity1$observed == disparity2$observed # is TRUE
@ 

\bibliographystyle{sysbio}
\bibliography{References}

\end{document}