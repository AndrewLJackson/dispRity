---
title: "dispRity metrics"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: References.bib
bst: sysbio.bst
vignette: >
  %\VignetteIndexEntry{dispRity metric}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


This vignette details how the disparity metrics are implemented in the `dispRity` package (v.0.2).

Disparity metrics
=================

There are many ways for measuring disparity. In brief, disparity is a summary metric that will represent an aspect of an ordinated space (e.g. MDS, PCA, PCO, PCoA).
For example, one can look at ellipsoid hyper-volume of the ordinated space [@DonohueDim], the sum and the product of the ranges and variances of the ordinated space dimensions [@Wills1994] or the median position of the elements in the ordinated space relative to its centroid [@GuillermeSTD].
Of course, there are many more examples of metrics one can use for describing some aspect of the ordinated space, with some performing better than other ones at particular descriptive tasks or some being more generalist.

Because of this great diversity of metric, the package `dispRity` has not a unique way to measure disparity but rather proposes to facilitate users to define their own disparity metric that will best suit to their particular analysis.
In fact, the core function of the package, `dispRity`, allows the user to define any metric in the `metric` argument.
However, because of the infrastructure of the package (especially the one of the `dispRity` objects â€“ see the [`dispRity` manual](https://github.com/TGuillerme/dispRity/blob/master/doc/dispRity-manual.pdf)), the `metric` argument has to follow certain rules:

1.  it must be composed of one to three `function` objects;

2.  these functions can only have as input a `matrix` or a `vector`;

3.  each of these functions must be of one of the three levels described below;

4.  at least one of the functions must be a level 1 function (see below).

The function levels
===================

The metric functions levels determine the dimensional level of decomposition of the input `matrix`.
In other words, each level designate the dimensions of the output: either three (a `matrix`); two (a `vector`); or one (a single `numeric` value) dimensions.

![Illustration of the different levels of output of a function with an input `matrix`](dispRity_fun.pdf)

A level 1 function
------------------

A level 1 function for example, will decompose a `matrix` or a `vector` into a single value:

```{r}
# First, let's create a dummy matrix
dummy_matrix <- matrix(rnorm(12), 4, 3)

# Any summary metric such as mean or median are good examples of level 1
# functions as they reduce the matrix to a single dimension (i.e. one value):
mean(dummy_matrix)
median(dummy_matrix)
```

A level 2 function
------------------

A level 2 function will decompose a `matrix` into a `vector`.
Several level 2 functions are implemented in `dispRity`(see `?dispRity.metric`) such as the `variances` function that calculates the variance of each dimension of the ordinated matrix.

```{r}
# We can define a function that outputs the products of each row of the matrix:
prod.rows <- function(matrix) apply(matrix, 1, prod)

# This function is a level 2 function as it reduces the matrix into a two
# dimensional element (a vector of values):
prod.rows(dummy_matrix)
```

A level 3 function
------------------

Finally a level 3 function will transform the `matrix` into another `matrix`.
Note that the dimension of the output `matrix` don't need to match the the input `matrix`:

```{r}
# The var functions computes the variance/covariance matrix which will be a
# three by three matrix
var(dummy_matrix)
```

`make.metric`
=============

Of course, functions can be more complex and involve multiple operations such as the `centroids` function (see `?dispRity.metric`) that calculates the euclidean distance between each elements and the ordinated space centroid.
The `make.metric` function implemented in `dispRity`is designed to help testing and finding the level of the functions.
This function tests:

1.  if your function can deal with a `matrix` or a `vector` as an input;

2.  which is your function's level according to it's output (level 1, 2 or 3, see above);

3.  whether the function can properly be implemented in the `dispRity` function (the function is fed into a `lapply` loop).

For example, let's see if the functions described above are the right levels:

```{r}
# First we need to load the package
library(dispRity)

# Which level is the mean function? And is able to be used in the dispRity?
make.metric(mean)

# Same questions from the prod.rows function:
make.metric(prod.rows)

# Same questions for the var function:
make.metric(var)
```

metric argument in `dispRity`
===========================================

Using this metric structure, on can easily use any disparity metric in the `dispRity`function as follows:

```{r}
# First we need to load the data
data(BeckLee_mat50)

# Measuring disparity as the standard deviation of all the value of the
# ordinated matrix (level 1 function).
summary(dispRity(BeckLee_mat50, metric = sd))

# Measuring disparity as the standard deviation of the variance of each axis of
# the ordinated matrix (level 1 and level 2 functions).
summary(dispRity(BeckLee_mat50, metric = c(sd, variances)))

# Measuring disparity as the standard deviation of the variance of each axis of
# the variance covariance matrix (level 1, level 2 and level 3 functions).
summary(dispRity(BeckLee_mat50, metric = c(sd, variances, var)), round = 10)
```

Note that the order of each function in the metric argument does not matter, the `dispRity`function will automatically detect the function levels (using `make.metric`) and apply them to the data in decreasing order (level 3 > level 2 > level 1).

```{r}
# Disparity as the standard deviation of the variance of each axis of the
# variance covariance matrix:
disparity1 <- summary(dispRity(BeckLee_mat50, metric = c(sd, variances, var)),
                      round = 10)

# Same but using a different functions order for the metric argument
disparity2 <- summary(dispRity(BeckLee_mat50, metric = c(variances, sd, var)),
                      round = 10)

# Both ways output the same disparity values:
disparity1$observed == disparity2$observed # is TRUE
```

What level is the disparity?
------------------

In these examples, we considered disparity to be a single value.
For example, in the previous one, we defined disparity as the standard deviation of the variances of each column of the variance/covariance matrix (`metric = c(variances, sd, var)`).
This results in single value to be calculated.

In some cases however, it might also be possible to calculate disparity as a distribution.
For example, one of the metrics commonly used in palaeobiology is the sum of variances of each dimensions (`metric = c(sum, variances)`) [@Wills1994].
However, it might be interesting to look directly at the distribution of the variances itself.

```{r}
# A one dimensional disparity
sum_variances1 <- summary(dispRity(BeckLee_mat50, metric = c(sum, variances)))

# A two dimensional disparity
all_variances <- summary(dispRity(BeckLee_mat50, metric = variances))

# Transforming the two dimensional one in a one dimensional one
sum_variances2 <- summary(dispRity(BeckLee_mat50, metric = sum))

# Both ways output the same disparity values:
sum_variances1$observed == sum_variances2$observed
```

# References