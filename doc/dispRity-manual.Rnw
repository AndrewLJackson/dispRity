\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}

\newcommand{\dispRity}{\texttt{dispRity} }
\newcommand{\R}{\texttt{R} }

\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


\title{\texttt{dispRity} manual}


\author{Thomas Guillerme}

\maketitle

\dispRity is a package for calculating disparity in \texttt{R}.
It allows to summarise ordinated matrices (e.g. MDS, PCA, PCO, PCoA) into single values.

\tableofcontents

\section{Before starting}
\subsection{Glossary}
Because this package is aimed to be multidisciplinary, many names or terms used in this tutorial might be non-familiar to certain fields.
Here is a list of what are the exact meaning of these term:
\begin{itemize}
\item \textbf{Ordinated space}: it designates the mathematical multidimensional object studied here. In morphometrics, this one is often referred as being the morphospace. However it can also be the the cladisto-space for cladistic data or the eco-space in ecology, etc. In practice, this term designates an ordinated matrix where the columns represent the dimensions of the ordinated space (often -- but not necessarily -- $>$ 3!) and the rows represent the elements within this space.
\item \textbf{Elements}: it designates the rows of the ordinated space, elements can be either taxa, field sites, countries, etc...
\item \textbf{Dimensions}: it designates the columns of the ordinated space. The dimensions can also be referred to as axis.
\item \textbf{Series}: it designates sub-samples of the ordinated space. Basically a series contain the same number of dimensions as the morphospace but might contain a smaller number of elements. For example, if our ordinated space is composed of birds and mammals (i.e. the elements) and 50 dimensions, we can create two series of just mammals or birds as elements (but the same 50 dimensions) to look at the difference in disparity between both groups.
\end{itemize}

\subsection{Installation}
You can install this package easily if you use the latest version of \R and \texttt{devtools}.

<<installation, eval=FALSE>>=
if(!require(devtools)) install.packages("devtools")
install_github("TGuillerme/dispRity", ref = "release")
library(dispRity)
@

\noindent Note that we use the \texttt{release} branch here which is version \Sexpr{packageVersion("dispRity")}.
For the piping-hot (but potentially full of bugs) version, you can change the argument \texttt{ref = "release"} to \texttt{ref = "master"}.
This package depends mainly on the \texttt{ape} package and the \texttt{timeSliceTree::paleotree} function.

\subsection{Data}
In this tutorial we are going to use a subset of the ordinated cladistic data from \cite{beckancient2014} that contains 50 taxa (elements) ordinated using their cladistic distance (i.e. the distance between their discrete morphological characters).
Note that this data is more oriented towards palaebiology analysis but that it can apply to other disciplines.
Please refer to the \href{https://github.com/TGuillerme/dispRity}{GitHub page: github.com/TGuillerme/dispRity} for other vignettes covering some specific example.

<<data, fig.width=8, fig.height=8, out.width='.8\\linewidth'>>=
## Loading the package
library(dispRity)

## Setting the random seed for repeatability
set.seed(123)

## Loading the ordinated matrix containing 50 taxa
data(BeckLee_mat50)
dim(BeckLee_mat50)
head(BeckLee_mat50[,1:5])

## Loading another ordinated matrix containing 50 tips + 49 nodes
data(BeckLee_mat99)
dim(BeckLee_mat99)
head(BeckLee_mat99[,1:5], 2)
tail(BeckLee_mat99[,1:5], 2)

## Loading a list of first and last occurrence data
data(BeckLee_ages)
head(BeckLee_ages)

## Loading the phylogeny
data(BeckLee_tree)
plot(BeckLee_tree) ; nodelabels(cex=0.8) ; axisPhylo(root=140)
@ 

\subsection{A quick go through}
Here is a really crude and quick analysis to go through the package, showing some of its features.
Note that all these features will be discussed in more details below.

<<Quick go, fig.width=5, fig.height=5, out.width='.5\\linewidth'>>=
## Splitting the data
sliced_data <- time.series(BeckLee_mat99, BeckLee_tree, method = "continuous",
    model = "acctran", time = rev(seq(from=0, to=130, by=15)),
    FADLAD = BeckLee_ages)
## Bootstrapping the data
bootstrapped_data <- boot.matrix(sliced_data, 100)
## Calculating disparity
sum_of_variances <- dispRity(bootstrapped_data, metric = c(sum, variances))
## Summarising the results
summary(sum_of_variances)
plot(sum_of_variances)
## Testing the effect of time on disparity
summary(test.dispRity(sum_of_variances, test = aov, comparisons = "all"))
@

\section{Package specificities}

\subsection{The \dispRity objects}
Disparity analysis can involve a lot of shuffling around with many matrices (especially when bootstrapping the data) which can be a bit impractical to visualise and quickly jam your \R console.
For example, we can have a look at the structure of the object created in the quick example:

<<dispRity class1, eval=FALSE>>=
str(sum_of_variances)
## That's a more than 4000 lines of output!
@

\noindent Therefore this package proposes a new class of object called \dispRity objects.
These objects allow to easily use a S3 method functions such as \texttt{summary.dispRity} (just called as \texttt{summary}; see section \ref{summary}) or \texttt{plot.dispRity} (just called as \texttt{plot}; see section \ref{plot}).
But also, this allows to use the S3 method for printing \dispRity objects via \texttt{print.dispRity} that allows to summarise the content of the objects similar to the \texttt{phylo} class objects (see \texttt{print.phylo::ape}).

<<dispRity class2>>=
## What is the class of the sum_of_variances object?
class(sum_of_variances)
## What is in the object?
names(sum_of_variances)
## Summarising it using the S3 method print.dispRity:
sum_of_variances
## This displays some basic information about the object content
@ 

\noindent Note however, that it is always possible to recall the full object using the argument \texttt{all=TRUE}:

<<dispRity class3, eval=FALSE>>=
## Displaying the full object
print(sum_of_variances, all = TRUE)
@ 

\noindent Finally, some utility functions such as \texttt{get.dispRity} or \texttt{extract.dispRity} allows to access to some specific content of the object:

<<dispRity class4>>=
## Extracting some specific series from the disparity object
series_1_and_4 <- get.dispRity(sum_of_variances, what = c(1,4))
series_1_and_4
## The observed disparity
extract.dispRity(sum_of_variances)
## The list of bootstrapped scores of disparity
str(extract.dispRity(sum_of_variances, observed = FALSE))
@

\subsection{Modular functions}
This package aims to be a modular package where users can personalise some aspects of the package fairly easily.
In this version \Sexpr{packageVersion("dispRity")} only one function is fully modular (\dispRity; see section \ref{disparity}) but more will be hopefully available in the near future (see section \ref{developments}).

The modular idea is that users can use implemented tools to help facilitating their own personalised function.
For example, the \dispRity function intake a \texttt{metric} argument designating how disparity should be calculated.
This argument can take some already implemented functions such as \texttt{mean} but also some completely new ones such as the sum divided by length:

<<dispRity modular>>=
## Disparity measured as the mean value of the ordinated matrix
summary(dispRity(sliced_data, metric = mean))
## A function for measuring the sum divided by the length (the mean!)
sum.divide.by.length <- function(X) sum(X)/length(X)
## Disparity measured as the mean divided by the length
summary(dispRity(sliced_data, metric = sum.divide.by.length))
## Giving the exact same results!
@

\noindent For more information concerning this modularity, please refer to the \href{https://github.com/TGuillerme/dispRity}{GitHub page: github.com/TGuillerme/dispRity} for the vignette about the metric implementation in \dispRity.

\section{Functions}
One of the first steps in disparity analysis is to split the ordinated space into sub-samples of this space (hereafter \textit{series}).
These series correspond to regions of the ordinated space that we want to compare to each other.

\subsection{\texttt{cust.series}}
The \texttt{cust.series} function allows to create these series according to factors determined by the user.
In this example, we can split the matrix based on the phylogeny and separate to different groups of taxa: the crown mammals (all the living mammals and their direct ancestor) and the stem mammals (all the mammals that have no direct offspring).

<<cust.series2>>=
## We want to separate the species around the node 71 (see phylogeny above).
## All the descendant of these node are crown and all the ancestors are stem.
crown <- extract.clade(BeckLee_tree, node = 71)$tip.label
stem <- drop.tip(BeckLee_tree, tip = crown)$tip.label
## We then have to feed this information in a data frame with one column
factors <- as.data.frame(
    matrix(data = c(rep("crown", length(crown)), rep("stem", length(stem))),
    ncol = 1, dimnames = list(c(crown, stem), "Group")))

## We then can use the customised series function to create the two series
## i.e. the two regions of the ordinated space
crown_stem <- cust.series(BeckLee_mat50, factors)

## This created a dispRity object containing two series: crown and stem
class(crown_stem)
crown_stem

## This object contains three elements
names(crown_stem)
## With "data" being the list sub-matrices
str(crown_stem$data)
## "elements" being the list of taxa in the original ordinated matrix
str(crown_stem$elements)
## and finally, "series" containing information on the series type (custom)
## and names (crown and stem)
crown_stem$series
@ 

\subsection{\texttt{time.series}}

Another way to split the ordinated space (maybe more relevant to palaeobiologists) is to do it according to time.
The \texttt{time.series} function allows to create series that contain all the elements present at specific points or during specific periods in time.
This functions needs as input an ordinated space and a matching phylogenetic tree.
Two types of time series can be performed by using the \texttt{method} option:
\begin{enumerate}
\item discrete time series (or time-binning) using \texttt{method = "discrete"};
\item continuous time series (or time-slicing) using \texttt{method = "continuous"}.
\end{enumerate}
For the time-slicing method details see \cite{GuillermeSTD}.
For both methods, the function intakes the \texttt{time} argument which can be a vector of \texttt{numeric} values for:
\begin{enumerate}
\item defining the boundaries of the time bins (when \texttt{method = "discrete"});
\item defining the time slices (when using \texttt{method = "continuous"}).
\end{enumerate}
Otherwise, the \texttt{time} argument can be set as a single \texttt{numeric} value for automatically generating a given number of equidistant time-bins/slices.
Additionally, it is also possible to input a data frame containing the First/Last Occurrence Data (\texttt{FAD/LAD}) for taxa that span over a longer time than the tips/nodes age.

Here is an example for \texttt{method = "discrete"}:

<<discrete.series>>=
## Generating three time bins containing the data present every 40 Ma
time_bins <- time.series(data = BeckLee_mat50, tree = BeckLee_tree,
    method = "discrete", time = c(120, 80, 40, 0))
## Note that the function provides a warning saying that tips where single
## points in time (no FAD/LAD information). We can fix that by adding the
## age data for the taxa that have some longer occurrence spans.
time_bins <- time.series(data = BeckLee_mat50, tree = BeckLee_tree,
    method = "discrete", time = c(120, 80, 40, 0), FADLAD = BeckLee_ages)
## To entirely avoid the warning we could collect the occurrence span data
## for all the taxa but that's not necessary. The function automatically
## assumes no occurrence span time (i.e. single points in time) for all taxa
## by default.
time_bins
@

\noindent This generated indeed a list of 3 sub matrices.
Note that we can also generate equivalent results by just telling the function that we want three time-bins (series) as follow: 

<<discrete.series2>>=
## Automatically generate three equal length bins:
time.series(data = BeckLee_mat50, tree = BeckLee_tree, method = "discrete",
    time = 3)
@
\noindent We now have three time bins of 44.50368 million years each.

When using this method, the oldest boundary of the first bin (or the first slice, see below) is automatically generated as being the root age + 1\% of the tree length as long as at least three elements are present at that point in time.
The algorithm adds an extra 1\% tree length until reaching the required minimum of three elements.
It is also possible to include nodes in each bin by using \texttt{inc.nodes = TRUE} and providing a matrix that contains the ordinated distance between tips \textit{AND} nodes.

For the time-slicing method (\texttt{method = "continuous"}), the idea is really similar.
This option intakes a matrix that contains the ordinated distance between taxa \textit{AND} nodes and an assumed evolutionary model via the \texttt{model} argument:
\begin{enumerate}
\item \texttt{"acctran"} where the data chosen on each time slice is always the one of the offspring
\item \texttt{"deltran"} where the data chosen on each time slice is always the one of the descendant
\item \texttt{"punctuated"} where the data chosen on each time slice is randomly chosen between the offspring or the descendant
\item \texttt{"gradual"} where the data chosen on each time slice is either the offspring or the descendant depending on branch length
\end{enumerate}

<<continuous.series>>=
## Generating four time slices every 40 million years assuming a gradual
## evolution model
time_slices <- time.series(data = BeckLee_mat99, tree = BeckLee_tree, 
    method = "continuous", model = "gradual", time = c(120, 80, 40, 0),
    FADLAD = BeckLee_ages)
time_slices
## Note that in the same way as for the discrete method, we can also
## automatically generate the slices
time.series(data = BeckLee_mat99, tree = BeckLee_tree, method = "continuous",
    model = "gradual", time = 4)
@


\subsection{\texttt{boot.matrix}}
\label{rare}

Once we obtain our different series, we might want to bootstrap and rarefy it (i.e. pseudo-replicating the data).
The bootstrap will allow us to make each subsample more robust to outliers and the rarefaction will allow us to compare slices with the same number of elements to get rid of eventual sampling problems.
The \texttt{boot.matrix} allows to bootstraps and rarefy ordinated matrices in a fast and easy way.
The default options will bootstrap the matrix 1000 times without rarefaction.
The number of bootstrap pseudo-replicates can be defined using the \texttt{bootstraps} option (see below).

<<boot.matrix1>>=
boot.matrix(data = BeckLee_mat50)
## As we can see, the output is also a dispRity object that is summarised
## automatically, and gives information on the data as well as the number of
## bootstraps and the bootstraps methods.
@

Additionally, this function allows to control the bootstrap algorithm through the \texttt{boot.type} argument.
Currently two algorithms are implemented:
\begin{enumerate}
\item \texttt{"full"} where the bootstrapping is entirely stochastic (all the data is bootstrapped)
\item \texttt{"single"} where only one random elements is replaced by one other random elements each pseudo-replication
\end{enumerate}

This function also allows to rarefy the data using the \texttt{rarefaction} argument.
The default argument is \texttt{FALSE} but it can be set to \texttt{TRUE} to fully rarefy the data (i.e. remove $n$ elements for the number of pseudo-replicates, where $n$ varies from the maximum number of elements present in the dataset to a minimum of 3 elements).
It can also be set to a fix \texttt{numeric} value (or a set of numeric values).
Finally, one last argument, \texttt{rm.last.axis} allows to remove a certain amount of dimensions (or axis) for the ordinated space.
This can be logical argument where \texttt{FALSE} (default) will not remove any dimension and \texttt{TRUE} will remove the last dimensions that bear up to 5\% of the total ordinated space's variance.

<<boot.matrix2>>=
## Bootstrapping with the single bootstrap method
boot.matrix(BeckLee_mat50, boot.type = "single")
## Bootstrapping with the full rarefaction
boot.matrix(BeckLee_mat50, bootstraps = 20, rarefaction = TRUE)
## Or with a set number of rarefaction levels
boot.matrix(BeckLee_mat50, bootstraps = 20, rarefaction = c(6:8,3))
## And removing the last axis (default)
boot.matrix(BeckLee_mat50, rm.last.axis = TRUE)
## Or with a fix value (50%)
boot.matrix(BeckLee_mat50, rm.last.axis = 0.5)
@

Of course, one could be interested in directly supplying the sub-sampled matrices generated above directly to this function.
In fact, it can also deal with a list of matrices or with a \dispRity object output from the \texttt{cust.series} or \texttt{time.series} functions.

<<boot.matrix3>>=
## Bootstrap and full rarefaction on the crown/stem series
crown_stemBS <- boot.matrix(crown_stem, bootstraps = 100, rarefaction = TRUE)
## Bootstrap on the time binning/slicing series
time_binsBS <- boot.matrix(time_bins, bootstraps = 100)
time_slicesBS <- boot.matrix(time_slices, bootstraps = 100)
## Note that all these objects are of class dispRity
crown_stemBS
time_binsBS
time_slicesBS
@

\subsection{\texttt{dispRity}}
\label{disparity}

This function is a modular function that allow to simply (and quickly!) calculate disparity from a matrix.

Because disparity can be measured in many ways, this function is a tool to measure disparity \textit{as defined by the user}.
In fact, the \dispRity function intakes two main arguments: the data and the disparity metric.
The disparity metric is a function or a set of functions that summarises the ordinated matrix to a single value that represents, in our example, the diversity of morphologies. 

The \dispRity algorithm decomposes the metrics functions into three levels that correspond to the dimensions of the output of each metric function.
For more details on this algorithm please refer to the \href{https://github.com/TGuillerme/dispRity}{metric vignette}.

In practice, the \dispRity function intakes one or more functions as a definition of disparity.
Several of these functions will be already implemented in other packages (such as \texttt{stats::median}, \texttt{base::sum}, etc.); some others are implemented in this package (listed in \texttt{?dispRity.metric}) and finally some others will be defined by the users.
The \texttt{make.metric} function is designed to help users create and test their own disparity metric functions.
In practice, the use of these metrics in the \dispRity function, is pretty easy:

<<dispRity1>>=
dispRity(BeckLee_mat50, metric = mean)
## This defines disparity as the mean value of the morphospace (using
## mean::base).

## It is also possible to combine multiple functions:
dispRity(BeckLee_mat50, metric = c(sum, variances))
## Defining disparity as the sum (sum::base) of the variances
## (variances::dispRity) of each dimension of the morphospace.

dispRity(BeckLee_mat50, metric = c(prod, centroids))
## For the product (prod::base) of the distances between each elements and the
## centroid of the morphospace (centroids::dispRity). 

## Or user defined ones:
total.range <- function(X) abs(range(X)[1]-range(X)[2])
dispRity(BeckLee_mat50, metric = c(total.range, centroids))
## For the range (total.range, user defined) of the distances between each
## elements and the centroid of the morphospace (centroids::dispRity).

## Or more complex ones:
vars1 <- dispRity(BeckLee_mat50, metric = c(sd, variances, var))
## For the standard deviation (sd::stats) of the variance (variances::dispRity)
## of each column of the variance/covariance matrix (var::stats).

## Note that the order of the function is not important since the levels of
## each function are automatically detected by the dispRity algorithm.
vars2 <- dispRity(BeckLee_mat50, metric = c(variances, var, sd))
all(summary(vars1) == summary(vars2))
@

\noindent Note that these functions do not directly output the disparity values but only the summary of the \dispRity objects.
To display the results, see the section \ref{summary}.

In these examples we used only simple ordinated matrix but of course, it might be more interesting to directly use the \dispRity objects we generated in the steps above.
Thus we can calculate the bootstrapped and rarefied disparity in each sub-sample of the morphospace.
In this example we are going to define disparity as being the sum of the variances in each dimension)=.

<<dispRity2>>=
## Disparity in crown and stem mammals:
disp_crown_stemBS <- dispRity(crown_stemBS, metric = c(sum, variances))

## Disparity through time:
disp_time_binsBS <- dispRity(time_binsBS, metric = c(median, centroids))
disp_time_slicesBS <- dispRity(time_slicesBS, metric = c(median, centroids))
@

\noindent Note that the computational time was longer for the rarefied data (\texttt{crown\_stemBS}) since it had to calculate the disparity on all the rarefied matrix, each bootstrapped 100 times.
A faster parallel version will be implemented in future releases (see section \ref{whatsleft}).


\subsection{\texttt{summary}}
\label{summary}

This function is a S3 function (\texttt{summary.dispRity}) allowing to summarize the content of \dispRity objects that contain disparity calculations.
This function intakes a \dispRity object plus various options namely the \texttt{quantile} values for the confidence intervals levels; the \texttt{cent.tend} for the central tendency to use for summarising the results and two \textit{visual} options which are whether to recall the \dispRity options and how much digits are wanted in the results.

<<summary>>=
summary(disp_time_binsBS)
## By default, the 50 and 95 quantiles and the mean are calculated.
## Note that the function also displays the observed disparity
## (non-bootstrapped).

## These arguments can be changed easily as follow
summary(disp_time_binsBS, quantile = 88, cent.tend = sd, rounding = 1)

## If on happens to forgot what was calculated in the summarised object,
## it is possible to recall the different steps details using recall:
summary(disp_time_binsBS, recall = TRUE)

## Note that the information with each different number of elements is
## displayed for rarefied data:
summary(disp_crown_stemBS)
## The observed disparity is NA for rarefied data.
@


\subsection{\texttt{plot}}
\label{plot}

A nicer way to summarise the data is to plot the results using the S3 method \texttt{plot.dispRity}.
This function intakes the same options as \texttt{summary.dispRity} along side with various graphical options described in the function manual (see \texttt{?plot.dispRity}).

Two main categories of plots can be displayed: discrete plots with the argument \texttt{type = "discrete"} and continuous plots with the argument \texttt{type = "continuous"} (see below).
Note that this argument can be left missing.
In this case, the algorithm will automatically detect the type of series from the \dispRity object.

The \texttt{type = "discrete"} argument plots superimposed boxes that represent the different levels of confidence intervals and a dot representing the central tendency.
It is also possible to display the number of elements per series (has a horizontal doted line) using the option \texttt{elements = TRUE}.
Additionally, when the data is rarefied (see section \ref{rare}), one can also indicate which level of rarefaction to display (i.e. display the results for a certain number of elements) by using the \texttt{rarefaction} argument. 

<<plot1, fig.width=15, fig.height=5, out.width='1\\linewidth'>>=
## Graphical options
quartz(width = 15, height = 5) ; par(mfrow = (c(1,3)), bty = "n")

## Plotting the disparity for both groups
plot(disp_crown_stemBS, type = "discrete")
## Same plot but with the number of elements on the right. Note that the type 
## argument is not necessary since the "discrete" type is automatically detected
## from the input dispRity object.
plot(disp_crown_stemBS, elements = TRUE)
## Rarefied version of the same plot (20 elements per series)
plot(disp_crown_stemBS, elements = TRUE, rarefaction = 20)
@

\noindent It is also possible to easily look at the behaviour of the disparity metric with the rarefied data (i.e. how does the disparity score change when the number of elements goes down) by using the \texttt{rarefaction = "plot"} argument:

<<plot2, fig.width=5, fig.height=8, out.width='0.5\\linewidth'>>=
## Graphical options
par(bty = "n")
## The rarefaction curves
plot(disp_crown_stemBS, elements = TRUE, rarefaction = "plot")
@

\noindent The different dashed lines represent the different confidence intervals around each rarefaction curve.
We can see that the disparity metric becomes stable after more than 10 elements.

It is also possible, when using the \texttt{type = "discrete"} argument, to plot lines rather than box by switching the \texttt{discrete\_type} from \texttt{"box"} to \texttt{"line"} to display one dimensional boxplots.
This option can be useful when displaying many series.
Additionally, it is possible to plot the observed data when existing (i.e. not when the data is rarefied) by using the option \texttt{observed = TRUE}.

<<plot3, fig.width=8, fig.height=8, out.width='.8\\linewidth'>>=
## Graphical options
par(bty = "n")
## The disparity-through-time data in a time-binned way (with lines rather than
## boxes) with the observed data as crosses
plot(disp_time_binsBS, discrete_type = "line", observed = TRUE)

@

The \texttt{type = "continuous"} argument plots superimposed continuous (along the x axis) polygons that represent the confidence intervals and a continuous line that represents the central tendency of the data.
Note that, as a S3 method function, \texttt{plot.dispRity} can take the classic graphical options from the \texttt{plot} function or even to add other plots to the previous ones.

<<plot4, fig.width=5, fig.height=5, out.width='.5\\linewidth'>>=
## Graphical options
par(bty = "n")

## First, plotting the continuous data with a y axis limit
plot(disp_time_slicesBS, type = "continuous", ylim = c(0.5,2))
## Note that the type = "continuous" argument is not mandatory here.

## Second, adding the discrete data
par(new = TRUE)
plot(disp_time_binsBS, discrete_type = "line", ylim=c(0.5,2), xlab="", ylab="")
@

\noindent I encourage you to play with the graphical options to have some prettier results.
Note that most of the options from \texttt{plot} can be passed to \texttt{plot.dispRity} via \texttt{...}.

<<plot5, fig.width=8, fig.height=8, out.width='.8\\linewidth'>>=
## Graphical options
par(bty = "n")
## A plot with many options!
plot(disp_time_slicesBS, quantile = c(seq(from=10, to=100, by=10)),
    cent.tend = sd, type = "continuous", elements = "log",
    col = c("black", rainbow(10)), ylab = c("Disparity", "log(Diversity)"),
    xlab = "Time (in in units from past to present)", time.series = FALSE,
    observed = TRUE, main = "Many options...")
@

\subsection{\texttt{test.dispRity}}

\subsection{utilities}
\subsubsection{\texttt{tree.age}}
This function allows to calculate the age of each individual nodes and tips in a tree.
It can either use the root age of the tree (if present as \texttt{\$root.time}) or else calculate the age using a user defined root age via the \texttt{age} argument.
Also, it is possible to decide whether the time is calculated towards the past (e.g. million years ago) or towards the present (e.g. in time since the origin).

<<tree.age>>=
## This tree has a root age
BeckLee_tree$root.time
## So we can get the age of each tips and nodes directly
head(tree.age(BeckLee_tree), 5)
## But we can also decide to make the age relative (between 1 and 0)
head(tree.age(BeckLee_tree, age = 1), 5)
## Or even relative, but from the root (i.e. how far are the nodes/tips
## from the root)
head(tree.age(BeckLee_tree, age = 1, order = "present"), 5)
@


\section{Developments}
\label{developments}
As stated at the start of the demo, this version \Sexpr{packageVersion("dispRity")} is still in development and many parts are missing.
Here are the new functionalities that will be implemented before the proper release version (v.1).

\subsection{More user defined stuff}
I intend also develop functions to help users to develop their own algorithms for the bootstrap method (via \texttt{make.boot}) or the evolutionary models (via \texttt{make.model}).
Both functions will provide similar testing as the \texttt{make.metric} function.

\subsection{Faster!}
Finally, for long analysis, I intend to develop a parallel running version of the package.
In fact, most of the internal functions are base on \texttt{lapply} functions that can be easily passed to \texttt{snow::parLapply} or similar parallel functions.

\bibliographystyle{sysbio}
\bibliography{References}

\end{document}