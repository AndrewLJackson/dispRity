\documentclass{article}
\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage{url}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}

\newcommand{\dispRity}{\texttt{dispRity} }
\newcommand{\R}{\texttt{R} }

\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
@


\title{\texttt{dispRity} manual}


\author{Thomas Guillerme}

\maketitle

\dispRity is a package for calculating disparity in \texttt{R}.
It allows to summarise ordinated matrices (e.g. MDS, PCA, PCO, PCoA) into single values.

\tableofcontents

\section{Before starting}
\subsection{Glossary}
Because this package is aimed to be multidisciplinary, many names or terms used in this tutorial might be non-familiar to certain fields.
Here is a list of what are the exact meaning of these term:
\begin{itemize}
\item \textbf{Ordinated space}: it designates the mathematical multidimensional object studied here. In morphometrics, this one is often referred as being the morphospace, or the cladisto-space for cladisticts or the eco-space for ecology, etc. In practice though, this term designates an ordinated matrix where the columns represent the dimensions of the ordinated space (often $>$ 3!) and the rows represent the elements within this space.
\item \textbf{Elements}: it designates the rows of the ordinated space, elements can be either taxa, field sites, countries, etc...
\item \textbf{Dimensions}: it designates the columns of the ordinated space. The dimensions can also be referred to as axis.
\item \textbf{Series}: it designates sub-samples of the ordinated space. Basically a series contain the same number of dimensions as the morphospace but might contain a smaller number of elements. For example, if our ordinated space is composed of birds and mammals (i.e. the elements) and 50 dimensions, we can create two series of just mammals or birds as elements (but the same 50 dimensions) to look at the difference in disparity between both groups.
\end{itemize}

\subsection{Installation}
You can install this package easily if you use the latest version of \R and \texttt{devtools}.

<<installation, eval=FALSE>>=
install.packages("devtools")
library(devtools)
install_github("TGuillerme/dispRity", ref = "release")
library(dispRity)
@

\noindent Note that we use the \texttt{release} branch here which is version \Sexpr{packageVersion("dispRity")}.
For the piping-hot (but potentially full of bugs) version, one can change the argument \texttt{ref = "release"} to \texttt{ref = "master"}.
This package depends mainly on the \texttt{ape} package and the \texttt{timeSliceTree::paleotree} function.

\subsection{Data}
In this tutorial we are going to use a subset of the ordinated cladistic data from \cite{beckancient2014} that contains 50 taxa ordinated using their cladistic distance (i.e. the distance between their discrete morphological characters).
Note that this data is more oriented towards palaebiology analysis but that it can apply to other disciplines.
Please refer to the \href{https://github.com/TGuillerme/dispRity}{GitHub page: github.com/TGuillerme/dispRity} for other vignettes covering some specific example of the package with ecological data.

<<data, fig.width=8, fig.height=8, out.width='.8\\linewidth'>>=
## Loading the package
library(dispRity)

## Setting the random seed for repeatability
set.seed(123)

## Loading the ordinated matrix containing 50 taxa
data(BeckLee_mat50)
dim(BeckLee_mat50)
head(BeckLee_mat50[,1:5])

## Loading another ordinated matrix containing 50 tips + 49 nodes
data(BeckLee_mat99)
dim(BeckLee_mat99)
head(BeckLee_mat99[,1:5], 2)
tail(BeckLee_mat99[,1:5], 2)

## Loading a list of first and last occurrence data
data(BeckLee_ages)
head(BeckLee_ages)

## Loading the phylogeny
data(BeckLee_tree)
plot(BeckLee_tree) ; nodelabels(cex=0.8) ; axisPhylo(root=140)
@ 

\subsection{A quick go through}
Here is a really crude and quick go through the package to show some of the features of this package.
Note that all these features will be discussed in more details below.

<<Quick go, fig.width=5, fig.height=5, out.width='.5\\linewidth'>>=
## Splitting the data
sliced_data <- time.series(BeckLee_mat99, BeckLee_tree, method = "continuous",
    model = "acctran", time = rev(seq(from=0, to=130, by=15)), FADLAD = BeckLee_ages)
## Bootstrapping the data
bootstrapped_data <- boot.matrix(sliced_data, 100)
## Calculating disparity
sum_of_variances <- dispRity(bootstrapped_data, metric = c(sum, variances))
## Summarising the results
summary(sum_of_variances)
plot(sum_of_variances)
## Testing some the effect of time on disparity
summary(test.dispRity(sum_of_variances, test = aov, comparisons = "all"))
@

\section{Package specificities}

\subsection{The \dispRity objects}
Disparity analysis can involve a lot of shuffling around with many matrices (especially when bootstrapping the data) which can be a bit impractical to visualise and quickly jam your \R console.
For example, we can have a look at the structure of the object created in the quick example:

<<dispRity class1, eval=FALSE>>=
str(sum_of_variances)
## That's a more than 4500 lines of output!
@

\noindent Therefore this package proposes a new class of object called \dispRity objects.
These objects allow to easily use a S3 method functions such as \texttt{summary.dispRity} (just called as \texttt{summary}; see section \ref{summary}) or \texttt{plot.dispRity} (just called as \texttt{plot}; see section \ref{plot}).
But also, this allows to use the S3 method for printing \dispRity objects via \texttt{print.dispRity} that allows to summarise the content of the objects similar to the \texttt{phylo} class objects (see \texttt{print.phylo::ape}).

<<dispRity class2>>=
## Which class is the sum_of_variances object?
class(sum_of_variances)
## What's in the object
names(sum_of_variances)
## We can summarise it using the S3 method print.dispRity
sum_of_variances
## This displays some information about what's in the object
@ 

\noindent Note however, that it is always possible to recall the full object using the argument \texttt{all=TRUE}:

<<dispRity class3, eval=FALSE>>=
## Displaying the full object
print(sum_of_variances, all=TRUE)
@ 

\noindent Finally, some utility functions such as \texttt{get.dispRity} or \texttt{extract.dispRity} allows to access to some specific content of the object:

<<dispRity class4>>=
## Extracting some specific series from the disparity object
series_1_and_4 <- get.dispRity(sum_of_variances, what=c(1,4))
series_1_and_4
## The observed disparity
extract.dispRity(sum_of_variances)
## The list of bootstrapped scores of disparity
str(extract.dispRity(sum_of_variances, observed = FALSE))
@

\subsection{Modular functions}
This package aims to be a modular package where users can personalise some aspects of the package fairly easily.
In this version \Sexpr{packageVersion("dispRity")} only one function is fully modular (\dispRity; see section \ref{disparity}) but more will be hopefully available in the near future (see section \ref{developments}).

The modular idea is that users can use implemented tools to help facilitating their own personalised function.
For example, the \dispRity function intake a \texttt{metric} argument designating how disparity should be calculated.
This argument can take some already implemented functions such as \texttt{mean} but also some completely new ones such as the sum divided by length:

<<dispRity modular>>=
## Disparity measured as the mean
summary(dispRity(sliced_data, metric = mean))
## A function for measuring the sum divided by the length (the mean!)
sum.by.length <- function(X)  sum(X)/length(X)
## Disparity measured as the mean divided by the length
summary(dispRity(sliced_data, metric = sum.by.length))
## Giving the exact same results!
@

\noindent For more information concerning this modularity, please refer to the \href{https://github.com/TGuillerme/dispRity}{GitHub page: github.com/TGuillerme/dispRity} for the vignette about the metric implementation in \dispRity.

\section{Functions}
One of the first steps in disparity analysis is to split the ordinated space into sub-samples of this space (hereafter \textit{series}).
These series correspond at regions of the ordinated space that we want to compare to each other.

\subsection{\texttt{cust.series}}
The \texttt{cust.series} function allows to create these series according to factors determined by the user.
In this example, we can split the matrix based on the phylogeny and separate to different groups of taxa: the crown mammals (all the living mammals and their direct ancestor) and the stem mammals (all the mammals that have no direct offspring).

<<cust.series2>>=
## We want to separate the species around the node 71 (see phylogeny above).
## All the descendant of these node are crown and all the ancestors are stem
crown <- extract.clade(BeckLee_tree, node = 71)$tip.label
stem <- drop.tip(BeckLee_tree, tip = crown)$tip.label
## We then have to feed this information in a data frame with one column
factors <- as.data.frame(
    matrix(data = c(rep("crown", length(crown)), rep("stem", length(stem))),
    ncol = 1, dimnames = list(c(crown, stem), "Group")))

## We then can use the customised series function to create the two series
## i.e. the two regions of the ordinated space
crown_stem <- cust.series(BeckLee_mat50, factors)

## This created a dispRity object containing two series: crown and stem
class(crown_stem)
crown_stem

## This object contains three elements
names(crown_stem)
## With "data" being the list sub-matrices
str(crown_stem$data)
## "taxa" being the list of taxa in the original ordinated matrix
str(crown_stem$taxa)
## and finally, "series" containing information on the series type (custom) and names
## (crown and stem)
crown_stem$series
@ 

\subsection{\texttt{time.series}}

Another way to split the ordinated space (maybe more relevant to palaeobiologists) is to do it according to time.
The \texttt{time.series} function allows to create series that contain all the elements present at specific points in time.
This functions needs as input an ordinated space and a matching phylogenetic tree.
Two types of time series can be performed by using the \texttt{method} option:
\begin{enumerate}
\item discrete time series (or time-binning) using \texttt{method = "discrete"};
\item continuous time series (or time-slicing) using \texttt{method = "continuous"}.
\end{enumerate}
For the time-slicing method details see \cite{GuillermeSTD}.
For both methods, the function intakes the \texttt{time} argument which can be a vector of \texttt{numeric} values for:
\begin{enumerate}
\item defining the boundaries of the time bins (when \texttt{method = "discrete"});
\item defining the time-slicing places (when using \texttt{method = "continuous"}).
\end{enumerate}
Otherwise, the \texttt{time} argument can be set as a single \texttt{numeric} value for automatically generating a given number of equidistant time-bins/slices.
Additionally, it is also possible to input a data frame containing the First/Last Occurrence Data (\texttt{FADLAD}) for taxa that span over a longer time than the tips/nodes age.

Here is an example for \texttt{method = "discrete"}:

<<discrete.series>>=
## Generating three time bins containing the data present every 40 Ma
time_bins <- time.series(data = BeckLee_mat50, tree = BeckLee_tree,
    method = "discrete", time = c(120, 80, 40, 0))
## Note that the function provides a warning saying that tips where single
## points in time (no FAD/LAD information). We can fix that by adding the
## age data for the taxa that have some longer occurrence spans.
time_bins <- time.series(data = BeckLee_mat50, tree = BeckLee_tree,
    method = "discrete", time = c(120, 80, 40, 0), FADLAD = BeckLee_ages)
## To entirely avoid the warning we could collect the occurrence span data
## for all the taxa but that's not necessary. The function automatically
## assumes no occurrence span time (i.e. single points in time) for all taxa
## by default.
time_bins
@

\noindent This generated indeed a list of 3 sub matrices.
Note that we can also generate equivalent results by just telling the function that we want three time-bins (series) as follow: 

<<discrete.series2>>=
## Automatically generate three equal length bins:
time.series(data = BeckLee_mat50, tree = BeckLee_tree, method = "discrete", time = 3)
@
\noindent We now have three time bins of 44.50368 Ma each.

When using this method, the oldest boundary of the first bin (or the first slice, see below) is automatically generated as being the root age + 1\% of the tree length as long as at least three elements are present at that point in time (an extra 1\% is added until reaching the required minimum of three elements).
We can also ask to include nodes in each bin by using \texttt{inc.nodes = TRUE} and providing a matrix that contains the ordinated distance between tips \textit{AND} nodes.

For the time-slicing method (\texttt{method = "continuous"}), the idea is really similar.
This option intakes a matrix that contains the ordinated distance between taxa \textit{AND} nodes and an assumed evolutionary model via the \texttt{model} argument:
\begin{enumerate}
\item \texttt{"acctran"} where the data chosen on each time slice is always the one of the offspring
\item \texttt{"deltran"} where the data chosen on each time slice is always the one of the descendant
\item \texttt{"punctuated"} where the data chosen on each time slice is randomly chosen between the offspring or the descendant
\item \texttt{"gradual"} where the data chosen on each time slice is either the offspring or the descendant depending on branch length
\end{enumerate}

<<continuous.series>>=
## Generating four time slices every 40 Ma assuming a gradual evolution model
time_slices <- time.series(data = BeckLee_mat99, tree = BeckLee_tree, 
    method = "continuous", model = "gradual", time = c(120, 80, 40, 0),
    FADLAD = BeckLee_ages)
time_slices
## Note that in the same way as for the discrete method, we can also
## automatically generate the slices
time.series(data = BeckLee_mat99, tree = BeckLee_tree, method = "continuous",
    model = "gradual", time = 4)
@


\subsection{\texttt{boot.matrix}}

Once we obtain our different series, we might want to bootstrap or/and rarefy it (i.e. pseudo-replicating the data).
The bootstrap will allow us to make each subsample more robust to outliers and the rarefaction will allow us to compare slices with the same number of elements to get rid of eventual sampling problems.
The \texttt{boot.matrix} allows to bootstraps and rarefy ordinated matrices in a fast and easy way.
The default options will bootstrap the matrix 1000 times without rarefaction.
The number of bootstrap pseudo-replicates can be defined using the \texttt{bootstraps} option (see below)
.
<<boot.matrix1>>=
boot.matrix(data = BeckLee_mat50)
## As we can see, the output is also a dispRity object that is summarised
## automatically, and gives information on the data as well as the number of
## bootstraps and the bootstraps methods.
@

Additionally, this function allows to control the bootstrap algorithm through the \texttt{boot.type} argument.
Currently two algorithms are implemented:
\begin{enumerate}
\item \texttt{"full"} where the bootstrapping is entirely stochastic (all the data is bootstrapped)
\item \texttt{"single"} where only one random elements is replaced by one other random elements each pseudo-replication
\end{enumerate}
This function also also to rarefy the data using the \texttt{rarefaction} argument.
The default argument is \texttt{FALSE} but it can be set to \texttt{TRUE} to fully rarefy the data (i.e. remove $n$ elements for the number of pseudo-replicates, where $n$ varies from the maximum number of elements present in the dataset to a minimum of 3 elements).
It can also be set to a fix \texttt{numeric} value (or a set of numeric values).
Finally, one last argument, \texttt{rm.last.axis} allows to remove a certain amount of dimensions (or axis) for the ordinated space.
This can be logical argument where \texttt{FALSE} (default) will not remove any dimension and \texttt{TRUE} will remove the last dimensions that bear up to 5\% of the total ordinated space's variance.

<<boot.matrix2>>=
## Bootstrapping with the single bootstrap method
boot.matrix(BeckLee_mat50, boot.type = "single")
## Bootstrapping with the full rarefaction
boot.matrix(BeckLee_mat50, bootstraps = 20, rarefaction = TRUE)
## Or with a set number of rarefaction levels
boot.matrix(BeckLee_mat50, bootstraps = 20, rarefaction = c(6:8,3))
## And removing the last axis (default)
boot.matrix(BeckLee_mat50, rm.last.axis = TRUE)
## Or with a fix value (50%)
boot.matrix(BeckLee_mat50, rm.last.axis = 0.5)
@

Of course, one could be interested in directly supplying the subsampled matrices generated above directly to this function.
In fact, it can also deal with a list of matrices or with a \dispRity object output from the \texttt{cust.series} or \texttt{time.series} functions.
let's bootstrap our previously generate series:

<<boot.matrix3>>=
## Bootstrap and full rarefaction on the crown/stem series
crown_stemBS <- boot.matrix(crown_stem, rarefaction = TRUE)
## Bootstrap on the time binning/slicing series
time_binsBS <- boot.matrix(time_bins)
time_slicesBS <- boot.matrix(time_slices)
## Note that all these objects are of class dispRity
crown_stemBS
time_binsBS
time_slicesBS
@

\subsection{\texttt{dispRity}}
\label{disparity}

Now we're going to see the functionalities of the core function of this package: the \dispRity function.
This function is a modulable function that allow to simply (and quickly!) calculate disparity from a matrix.

Because disparity can be measured in many ways, this function is a tool to measure disparity \textit{as defined by the user} (and here's where the modulable part comes in).
In fact, the \dispRity function intakes two main arguments: the data and the disparity metric.
%To change in future version!
The disparity metric boils down to a single value that describes the matrix.
Some are classic like the sum or the product of the ranges or the variances of the matrix columns (i.e. the any-o-space axis/dimensions) \cite{Wills1994}.
However, many more exist like the median distances between the taxa and the any-o-space centroid \cite{GuillermeSTD}.

One can usually decompose the disparity metrics into two elements:
\begin{enumerate}
\item the \textbf{class metric} that is a descriptor of the matrix. For example describing the ranges of each column in the matrix or the euclidean distances between each row and the centroid of the matrix.
\item the \textbf{summary metric} that is a summary of the class metric values. For example, the sum of the ranges or the median of the euclidean distances. 
\end{enumerate}
Basically the combination can be infinite between the class and summary metrics.
For example, people might want to measure the median variances of the axis or the product of the distances from the centroid.
However, it is probable that some metrics are better to reflect some biological aspects of the any-o-space than others (see section \ref{whatsleft})...

In practice, the \dispRity function intakes a pair of class and summary metrics as a definition of disparity.
Several of these metrics are implemented in other packages (like \texttt{stats::median}, \texttt{base::sum}, etc.) and this package proposes several metrics listed in \texttt{dispRity.metric} (see \texttt{?dispRity.metric}).
It is even possible to use your very own class and summary metrics!
This will be actually heavily encouraged and facilitate with the \texttt{make.metric} function in a future version (see \ref{whatsleft}).

To use these metrics pairs in the \dispRity function, it's pretty easy:

<<dispRity1>>=
dispRity(BeckLee_mat50, metric = c(sum, ranges))
## Yep, that's it. The order of the metrics does not matter (the function detects
## automatically which one is the class and the summary metric) so the combinations
## are numerous!
dispRity(BeckLee_mat50, metric = c(sum, variances))
dispRity(BeckLee_mat50, metric = c(prod, centroids))
dispRity(BeckLee_mat50, metric = c(mode.val, ranges))
## Or funny user defined ones!
total.range <- function(X) abs(range(X)[1]-range(X)[2])
dispRity(BeckLee_mat50, metric = c(total.range, ranges))
## That would be disparity as the range of the axis ranges!
@

Of course, this function can take a simple ordinated matrix but, more interesting it can also deal with a list of matrices (from the \texttt{cust.series} or \texttt{time.series} functions for example) or a bootstrapped or/and rarefied matrix (from the \texttt{boot.matrix} function for example).

<<dispRity2>>=
## For example, let's calculate the sum of variances from our crown/stem mammals
dispRity(crown_stem, metric = c(sum, variances))
## Or even better, from the bootstrapped data
disp_crown_stemBS <- dispRity(crown_stemBS, metric = c(sum, variances))
## Note that the bootstrapped + rarefied data takes some time to run (it's
## calculating disparity from 46 matrices!)

## Let's calculate a different metric for the disparity-through-time analysis
disp_time_binsBS <- dispRity(time_binsBS, metric = c(median, centroids))
disp_time_slicesBS <- dispRity(time_slicesBS, metric = c(median, centroids))
@

Again, note that the results are \dispRity objects and can displayed through the S3 \texttt{print.dispRity} method to remind users what are in these objects.
Also note that an even faster parallel version will be developed in the future (see section \ref{whatsleft}).

\subsection{\texttt{summary}}
\label{summary}

As shown in these examples above however, even though the disparity has been calculated in many way, the function doesn't directly outputs the results, rather just a summary of the analysis.
To really display the results we can use the S3 \texttt{summary.dispRity} and \texttt{plot.dispRity} functions.

\subsubsection{\texttt{summary} function}
This function intakes a \dispRity object plus various options namely the \texttt{quantile} values for the confidence intervals levels; the \texttt{cent.tend} for the central tendency to use for summarising the results and two \textit{visual} options which are whether to recall the \dispRity options and how much digits are wanted in the results.

<<summary>>=
## Let's have a look at the disparity-through-time using in the time-binned data
summary(disp_time_binsBS)
## The 50 and 95 quantiles are calculated and the central tendency is the mean by default.
## Note that the function also displays the observed disparity (non-bootstrapped).
## We can change that easily by specifying different values in the options
summary(disp_time_binsBS, quantile = 88, cent.tend = sd, rounding = 1)
## Also, if we happen to have forgotten what was in the disp_time_binsBS object (as in
## which options where used to modify the original matrix) we can use the recall option:
summary(disp_time_binsBS, recall = TRUE)
## Note that the recall just prints text. The output of summary.dispRity is always a
## data.frame
summary_table <- summary(disp_time_binsBS, recall = TRUE)
class(summary_table)

## Finally we can see the results of the rarefaction analysis for the crown/stem data
head(summary(disp_crown_stemBS))
## This outputs a longer table with all the variations of the number of crown/stem taxa
## from the maximum (30 and 20) to the minimum (3). Note that the observed disparity
## is NA for rarefied data.
@


\subsection{\texttt{plot}}
\label{plot}

This final function allows to visualise the disparity results in a often nicer fashion than just a table (even though the exact same data is displayed).
The \texttt{plot.dispRity} option intakes the same options as \texttt{summary.dispRity} along side with various graphical options described in the function manual.
Here, let's just have a look a few of these options.

Let's start with plotting the difference in disparity between the crown and the stem mammals.
For this we are going to simply specify the type of plots using the \texttt{type} option that allows to choose between the \texttt{"continuous"} or \texttt{"discrete"} method.
In our case, we are interested in looking at the results in a discrete way.
Note that the plot \texttt{type} can be left missing.
The function will then use \texttt{"discrete"} as default or \texttt{"continuous"} if the input data came from the \texttt{time.series} function with \texttt{method = "continuous"}.

The grey squares represent the confidence intervals (50 in dark grey and 90 in light grey) and the dot represents the mean.
However, it might be interesting to see how many taxa are present in each group.
This can be done via the \texttt{elements} option.
A third interesting option is to plot the rarefied data if a rarefaction was applied on the data with the \texttt{boot.matrix} function.
For displaying the rarefied data we can use the \texttt{rarefaction} option.
This option can be either \texttt{FALSE} (default) for always plotting the maximum number of taxa per series or \texttt{TRUE} to always plot the minimum.
Additionally, it can be a specific number to plot a specific number of taxa.
Let say we want both groups to have 20 taxa maximum.
We can see now that the confidence intervals overlap more than previously

<<plot1, fig.width=15, fig.height=5, out.width='1\\linewidth'>>=
## Graphical options
quartz(width = 15, height = 5) ; par(mfrow = (c(1,3)), bty = "n")
## Plotting the score for both groups
plot(disp_crown_stemBS, ylim = c(25,40))
## Same one with the number of taxa for each data set
plot(disp_crown_stemBS, elements = TRUE, ylim = c(25,40))
## Same one with rarefied data (note how that affects the elements data as well!)
plot(disp_crown_stemBS, elements = TRUE, rarefaction = 20, ylim = c(25,40))
@

To understand how the number of taxa affects each series, we can use the \texttt{rarefaction = "plot"} function to plot the rarefaction curves.

<<plot2, fig.width=5, fig.height=8, out.width='0.5\\linewidth'>>=
## Graphical options
par(bty = "n")
## The rarefaction curves
plot(disp_crown_stemBS, elements = TRUE, rarefaction = "plot")
## Note that the function automatically draws the curves for each series and splits
## the plot screen accordingly.
@

The different dashed lines represent the different confidence intervals around each rarefaction curve.

Additionally, for the \texttt{type = "discrete"} option, we might also decide to plot many boxplots (which can be a bit messy).
The \texttt{discrete\_type} option allows to switch between \texttt{"box"} or \texttt{"line"} for showing the results in one or the other format.
We can also plot the observed data when existing (i.e. not with some rarefaction levels) by using \texttt{observed = TRUE}.
Let's look at that with the time binned data (even though there is only three time bins).
Finally, we can use the \texttt{type = "continuous"} option that comes in handy for plotting continuous data like in the time sliced analysis (obviously...).


<<plot3, fig.width=10, fig.height=5, out.width='1\\linewidth'>>=
## Graphical options
quartz(width = 10, height = 5) ; par(mfrow = (c(1,2)), bty = "n")
## The disparity-through-time data in a time-binned way (with lines rather than
## boxes) with the observed data as crosses
plot(disp_time_binsBS, discrete_type = "line", observed = TRUE)
## The disparity-through-time data in a time-sliced ways
plot(disp_time_slicesBS)

@

We can even plot both results (discrete and continuous) on the same graph:

<<plot4, fig.width=5, fig.height=5, out.width='.5\\linewidth'>>=
## Graphical options
par(bty = "n")
## First, plotting the continuous data
plot(disp_time_slicesBS, ylim=c(0.5,2))
## Second, adding the discrete data
par(new = TRUE)
plot(disp_time_binsBS, discrete_type = "line", ylim=c(0.5,2), xlab="", ylab="")
@

Note that the results vary in values but not in pattern.
The change in values might be due to the fact that nodes data are not included in the discrete analysis.

I encourage you to play with the graphical options to have some prettier results.
Note that most of the options from \texttt{plot} can be passed to \texttt{plot.dispRity} via \texttt{...}.

<<plot5, fig.width=8, fig.height=8, out.width='.8\\linewidth'>>=
## Graphical options
par(bty = "n")
## A plot with many options!
plot(disp_time_slicesBS, quantile = c(seq(from=10, to=100, by=10)), cent.tend = sd,
    type = "continuous", elements = "log", col = c("black", rainbow(10)),
    ylab = c("Disparity", "log(Diversity)"), xlab = "Time (in in units from
    past to present)", time.series = FALSE, observed = TRUE, main = "Many options...")
@

\subsection{\texttt{test.dispRity}}

\subsection{utilities}
\subsubsection{\texttt{tree.age}}
This function allows to calculate the age of each individual nodes and tips in a tree.
It can either use the root age of the tree (if present as \texttt{\$root.time}) or else calculate the age using a user defined root age via the \texttt{age} argument.
Also, it is possible to decide whether the time is calculated towards the past (e.g. million years ago) or towards the present (e.g. in time since the origin).

<<tree.age>>=
## This tree has a root age
BeckLee_tree$root.time
## So we can get the age of each tips and nodes directly
head(tree.age(BeckLee_tree), 5)
## But we can also decide to make the age relative (between 1 and 0)
head(tree.age(BeckLee_tree, age = 1), 5)
## Or even relative, but from the root (i.e. how far are the nodes/tips
## from the root)
head(tree.age(BeckLee_tree, age = 1, order = "present"), 5)
@


\section{Developments}
\label{developments}
As stated at the start of the demo, this version \Sexpr{packageVersion("dispRity")} is still in development and many parts are missing.
Here are the new functionalities that will be implemented before the proper release version (v.1).

\subsection{More user defined stuff}
I intend also develop functions to help users to develop their own algorithms for the bootstrap method (via \texttt{make.boot}) or the evolutionary models (via \texttt{make.model}).
Both functions will provide similar testing as the \texttt{make.metric} function.

\subsection{Faster!}
Finally, for long analysis, I intend to develop a parallel running version of the package.
In fact, most of the internal functions are base on \texttt{lapply} functions that can be easily passed to \texttt{snow::parLapply} or similar parallel functions.

\bibliographystyle{sysbio}
\bibliography{References}

\end{document}